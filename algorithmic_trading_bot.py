# -*- coding: utf-8 -*-
"""Algorithmic Trading Bot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wq8Jl4mYD-gcJSY6XG1rMfHPGe73ZFEm
"""

!pip install pandas numpy matplotlib seaborn TA-Lib technical-analysis-library-in-python ccxt alpaca-trade-api backtrader zipline

import pandas as pd
import numpy as np
import yfinance as yf
from alpaca_trade_api.rest import REST, TimeFrame
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM
from tensorflow.keras.optimizers import Adam

data = yf.download("AAPL", start="2015-01-01", end="2023-01-01")

alpaca = REST('######', '######', base_url='https://paper-api.alpaca.markets')

barset = alpaca.get_barset('AAPL', TimeFrame.Minute, limit=100)

# Calculate technical indicators
data['SMA20'] = data['Close'].rolling(window=20).mean()
data['SMA50'] = data['Close'].rolling(window=50).mean()

# Example RSI calculation
def calculate_rsi(series, window):
    delta = series.diff(1)
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    return 100 - (100 / (1 + rs))

data['RSI'] = calculate_rsi(data['Close'], window=14)

# Create target variable: 1 if the next day's close is higher, else 0
data['Target'] = np.where(data['Close'].shift(-1) > data['Close'], 1, 0)

# Splitting data into training and testing sets
train_size = int(len(data) * 0.7)
train_data = data[:train_size].dropna()
test_data = data[train_size:].dropna()

# Features and target for training
X_train = train_data[['SMA20', 'SMA50', 'RSI']].values
y_train = train_data['Target'].values

# Features and target for testing
X_test = test_data[['SMA20', 'SMA50', 'RSI']].values
y_test = test_data['Target'].values

# Train a Random Forest model
model_rf = RandomForestClassifier(n_estimators=100, random_state=42)
model_rf.fit(X_train, y_train)

# Predicting on the test set
predictions_rf = model_rf.predict(X_test)

# Accuracy of the model
accuracy_rf = accuracy_score(y_test, predictions_rf)
print(f"Random Forest Accuracy: {accuracy_rf:.2f}")

# Prepare data for LSTM (reshape to 3D array)
X_train_lstm = X_train.reshape((X_train.shape[0], X_train.shape[1], 1))
X_test_lstm = X_test.reshape((X_test.shape[0], X_test.shape[1], 1))

# Build LSTM model
model_lstm = Sequential()
model_lstm.add(LSTM(50, return_sequences=True, input_shape=(X_train_lstm.shape[1], 1)))
model_lstm.add(LSTM(50))
model_lstm.add(Dense(1, activation='sigmoid'))

# Compile the model
model_lstm.compile(optimizer=Adam(), loss='binary_crossentropy', metrics=['accuracy'])

# Train the model
model_lstm.fit(X_train_lstm, y_train, epochs=10, batch_size=32, validation_data=(X_test_lstm, y_test))

# Predicting on the test set
predictions_lstm = (model_lstm.predict(X_test_lstm) > 0.5).astype("int32")

# Accuracy of the LSTM model
accuracy_lstm = accuracy_score(y_test, predictions_lstm)
print(f"LSTM Accuracy: {accuracy_lstm:.2f}")

# Generate signals based on Moving Average Crossover
data['Signal'] = np.where(data['SMA20'] > data['SMA50'], 1, -1)

# Trading decision based on both signals
data['Position'] = 0
data['Position'][train_size:] = np.where(predictions_rf == 1, 1, 0)  # Use RF model prediction
data['Position'][train_size:] = data['Position'] * data['Signal'][train_size:]

# Backtest strategy by calculating returns
data['Strategy_Return'] = data['Position'].shift(1) * data['Close'].pct_change()

# Calculate cumulative returns
data['Cumulative_Strategy_Return'] = (1 + data['Strategy_Return']).cumprod()

# Plot results
plt.figure(figsize=(14,7))
plt.plot(data['Cumulative_Strategy_Return'], label='Strategy Return')
plt.plot((1 + data['Close'].pct_change()).cumprod(), label='Market Return')
plt.legend()
plt.show()

def execute_trade(symbol, qty, side):
    alpaca.submit_order(
        symbol=symbol,
        qty=qty,
        side=side,
        type='market',
        time_in_force='gtc'
    )

import time

# Continuous trading loop
while True:
    # Fetch real-time data
    barset = alpaca.get_barset('AAPL', TimeFrame.Minute, limit=1)
    current_price = barset['AAPL'][-1].c

    # Add your trading logic here

    time.sleep(60)  # Wait for 1 minute before the next iteration